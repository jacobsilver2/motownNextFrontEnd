{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useState } from \"react\";\nimport gql from \"graphql-tag\";\nimport { useQuery } from \"@apollo/react-hooks\";\nimport ErrorMessage from \"./ErrorMessage\";\nimport styled from \"styled-components\";\nimport Link from \"next/link\"; // import { Card } from \"primereact/card\";\n\nimport ComponentCard from \"./Card\";\nimport formatDate from \"../lib/formatDate\";\nconst SingleSongStyles = styled.div.withConfig({\n  displayName: \"SingleSong__SingleSongStyles\",\n  componentId: \"sc-1e0bt3h-0\"\n})([\"max-width:1200px;margin:2rem auto;box-shadow:\", \";display:grid;grid-auto-columns:1fr;grid-auto-flow:column;min-height:800px;.title{text-align:center;}.details{margin:3rem;font-size:2rem;}\"], props => props.theme.bs);\nconst ComponentTitleCard = styled(ComponentCard).withConfig({\n  displayName: \"SingleSong__ComponentTitleCard\",\n  componentId: \"sc-1e0bt3h-1\"\n})([\"text-align:center;\"]);\nconst PerformedByAndRecordingspane = styled.div.withConfig({\n  displayName: \"SingleSong__PerformedByAndRecordingspane\",\n  componentId: \"sc-1e0bt3h-2\"\n})([\"display:grid;grid-template-columns:1fr 1fr;\"]);\nconst SINGLE_SONG_QUERY = gql`\n  query SINGLE_SONG_QUERY($id: ID!) {\n    song(where: { id: $id }) {\n      id\n      title\n      composer {\n        id\n        name\n      }\n      publisher\n      publishedDate\n      altTitle\n      instrumental\n      fromFilm\n      tribute\n      artists {\n        id\n        name\n      }\n      albums {\n        id\n        title\n      }\n      recordings {\n        id\n        producer\n        location\n        completed\n        albums {\n          id\n          title\n        }\n        song {\n          id\n          title\n        }\n      }\n    }\n  }\n`;\n\nconst SingleSong = ({\n  id\n}) => {\n  const {\n    loading,\n    error,\n    data\n  } = useQuery(SINGLE_SONG_QUERY, {\n    variables: {\n      id\n    }\n  });\n  const {\n    0: layout,\n    1: setLayout\n  } = useState(\"list\");\n  if (error) return __jsx(ErrorMessage, {\n    error: error\n  });\n  if (loading) return __jsx(\"p\", null, \"Loading...\");\n  if (!data.song) return __jsx(\"p\", null, \"No song found for \", id);\n  const {\n    title,\n    composer,\n    publisher,\n    publishedDate,\n    altTitle,\n    instrumental,\n    fromFilm,\n    tribute,\n    artists,\n    albums,\n    recordings\n  } = data.song;\n  const composerNames = composer.map((comp, index) => {\n    let trailingChar = \", \";\n\n    if (composer && index === composer.length - 2) {\n      trailingChar = \"& \";\n    }\n\n    if (composer && !composer[index + 1]) {\n      trailingChar = \"\";\n    }\n\n    return __jsx(\"span\", {\n      key: comp.id\n    }, __jsx(Link, {\n      href: {\n        pathname: \"/composer\",\n        query: {\n          id: comp.id\n        }\n      }\n    }, __jsx(\"a\", null, comp.name, \" \")), trailingChar);\n  });\n  const albumsCards = albums.map(album => {\n    return __jsx(ComponentCard, {\n      key: album.id,\n      title: __jsx(Link, {\n        href: {\n          pathname: \"album\",\n          query: {\n            id: album.id\n          }\n        }\n      }, __jsx(\"a\", null, album.title))\n    }, renderAlbumRecordings(album));\n  }); // const matchedAlbumRecording = recordings.filter(recording => {\n  //   recording.albums.forEach(album => (\n  //     album.title ===\n  //   ))\n  // })\n\n  function renderAlbumRecordings(theAlbum) {\n    const matchedAlbumRecordingInfo = {};\n    recordings.forEach(recording => {\n      recording.albums.forEach(album => {\n        if (album.id === theAlbum.id) {\n          matchedAlbumRecordingInfo.producer = recording.producer, matchedAlbumRecordingInfo.location = recording.location, matchedAlbumRecordingInfo.id = recording.id, matchedAlbumRecordingInfo.completed = recording.completed;\n        }\n      });\n    });\n    return __jsx(\"ul\", {\n      key: matchedAlbumRecordingInfo.id,\n      style: {\n        listStyleType: \"none\",\n        margin: 0,\n        padding: 0\n      }\n    }, matchedAlbumRecordingInfo.producer && __jsx(\"li\", null, \"Produced By: \", matchedAlbumRecordingInfo.producer), matchedAlbumRecordingInfo.location && __jsx(\"li\", null, \"Recording Location: \", matchedAlbumRecordingInfo.location), matchedAlbumRecordingInfo.completed && __jsx(\"li\", null, \"Completed: \", formatDate(matchedAlbumRecordingInfo.completed)));\n  }\n\n  return __jsx(React.Fragment, null, __jsx(ComponentCard, {\n    isTitle: true,\n    title: title,\n    subTitle: composerNames\n  }, altTitle && __jsx(\"h3\", {\n    className: \"alttitle\"\n  }, \"Alt Title: \", altTitle), publisher && __jsx(\"h3\", {\n    className: \"publisher\"\n  }, \"Publisher: \", publisher), publishedDate && __jsx(\"h3\", {\n    className: \"publisheddate\"\n  }, \"Published Date: \", formatDate(publishedDate)), instrumental && __jsx(\"h3\", {\n    className: \"instrumental\"\n  }, \"Instrumental\"), fromFilm && __jsx(\"h3\", {\n    className: \"fromfilm\"\n  }, \"From Film: \", fromFilm)), __jsx(PerformedByAndRecordingspane, null, artists && __jsx(ComponentCard, {\n    title: \"Performed by: \"\n  }, __jsx(\"ul\", {\n    style: {\n      listStyleType: \"none\",\n      margin: 0,\n      padding: 0\n    }\n  }, artists.map(artist => __jsx(\"li\", {\n    key: artist.id\n  }, __jsx(Link, {\n    href: {\n      pathname: \"artist\",\n      query: {\n        id: artist.id\n      }\n    }\n  }, __jsx(\"a\", null, artist.name)))))), albums && __jsx(ComponentCard, {\n    title: `Can be heard on the album${albums.length > 1 ? \"s\" : \"\"}:`\n  }, albumsCards)));\n};\n\nexport default SingleSong;","map":null,"metadata":{},"sourceType":"module"}